<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Advanced &#8212; Stitch  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Arrows" href="Arrows.html" />
    <link rel="prev" title="Recursion" href="Recursion.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="advanced">
<span id="id1"></span><h1>Advanced<a class="headerlink" href="#advanced" title="Link to this heading">¶</a></h1>
<p>The topics covered in this doc are generally beyond the scope of what is needed to utilize Stitch on a day-to-day basis.</p>
<section id="ordering">
<span id="id2"></span><h2>Ordering<a class="headerlink" href="#ordering" title="Link to this heading">¶</a></h2>
<p>Stitch has no ordering guarantees about which keys will end up in which batches to backends.
What that means is that there’s no way to know ahead of time which keys will be with which
other keys in a given RPC. Because the order in which collected calls isn’t guaranteed, it’s
important to compose your Stitch query so that dependent operations are truly dependent.
If <cite>x</cite> must happen after <cite>y</cite> then they should be composed to ensure that, such as <cite>x.flatMap(y)</cite>
and not depend on what order you think will occur, such as <cite>Stitch.join(x, y)</cite> which has no
guarantee that parts of <cite>x</cite> will run before parts of <cite>y</cite>.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SeqGroup</span><span class="p">[</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nc">Int</span><span class="p">]{</span>
<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Int</span><span class="p">]):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Try</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="w">    </span><span class="nc">Future</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="nc">Return</span><span class="p">(</span><span class="n">_</span><span class="p">)))</span>
<span class="p">}</span>
<span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">maxSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="p">}</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">99</span><span class="p">)(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: Seq(0,1,2,...,97,98,99)</span>
</pre></div>
</div>
<p>In the above example, an initial thought may be that the batches would be [0-9, 10-19, … 90-99]
however there’s not likely to be the case in the real world. The batches should be assumed to be
random and are just as likely to be [[11, 19, 95, 41, 45, 25, 83, 34, 20, 6], …]. This is due to
keys being stored in a <a class="reference external" href="https://docs.oracle.com/javase/10/docs/api/java/util/HashSet.html">Set</a>
with no guarantees about ordering, and second is that the order in which keys are aggregated
during simplification is not consistent for non-trivial Stitches.</p>
<p>While the key ordering that your backend receives may be essentially random, the ordering that
you get back will be correct. In the above example, even though the inputs are run in arbitrary
batches with no ordering, you will still get back the results in the same order in which they
were passed in.</p>
<p>The below example adds a brief random delay to simulate previous calls finishing at different
times, so the calls to g aren’t in a consistent order. By running the below snippet you can
see that the batches are random but the final result is in the correct order.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">timer</span><span class="p">:</span><span class="w"> </span><span class="nc">Timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">JavaTimer</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SeqGroup</span><span class="p">[</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nc">Int</span><span class="p">]{</span>
<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Int</span><span class="p">]):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Try</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="w">    </span><span class="nc">Future</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="nc">Return</span><span class="p">(</span><span class="n">_</span><span class="p">)))</span>
<span class="p">}</span>
<span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">maxSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="p">}</span>

<span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">99</span><span class="p">){</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span>
<span class="w">        </span><span class="nc">Duration</span><span class="p">.</span><span class="n">fromMilliseconds</span><span class="p">(</span><span class="n">scala</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="nc">Random</span><span class="p">.</span><span class="n">nextInt</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="p">).</span><span class="n">flatMap</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// paste the below in separately due to an issue with the repl</span>

<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: Seq(0,1,2,...,97,98,99)</span>
</pre></div>
</div>
<p>You may have noticed that there were likely more than 10 batches, that’s because when each
<cite>sleep</cite> finishes, it simplifies the graph, so any keys whose sleep is also finished at that
moment will also be able to be batched, due to small timing differences things aren’t perfect,
but it illustrates the point.</p>
</section>
<section id="bucketed-groups">
<span id="id3"></span><h2>Bucketed Groups<a class="headerlink" href="#bucketed-groups" title="Link to this heading">¶</a></h2>
<p>In most cases, a simple <cite>MapGroup</cite> or <cite>SeqGroup</cite> are all that will be needed though Stitch
allows for some additional options. For some services, it may be beneficial to keep certain
calls together in the same RPC. If it’s important to keep certain keys together then the
<cite>BucketedSeqGroup</cite> or <cite>BucketedMapGroup</cite> can be used instead.
This allows the implementer to define</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">bucket</span><span class="p">(</span><span class="n">key</span><span class="p">:</span><span class="w"> </span><span class="nc">Key</span><span class="p">):</span><span class="w"> </span><span class="nc">B</span>
</pre></div>
</div>
<p>which will try to put keys in the same bucket together in the same RPC. By default this strategy will split
small buckets to optimize the number of RPCs that are performed, however this is configurable with</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">packingStrategy</span><span class="p">:</span><span class="w"> </span><span class="nc">BatchPackingStrategy</span>
</pre></div>
</div>
</section>
<section id="runners">
<span id="id4"></span><h2>Runners<a class="headerlink" href="#runners" title="Link to this heading">¶</a></h2>
<p><cite>Runners</cite> are what power <cite>Groups</cite>. They are pretty deep into the Stitch implementation and
unlikely to ever be touched by people outside of the Stitch maintainers.
However, there are some interesting things that <cite>Runners</cite> do.</p>
<p>Users often will use Groups, but for the most part, a Group delegates almost everything to the Runner.
Runners are responsible for which keys end up in which batches, creating the correct batch sizes,
maintaining the concurrency limits, and invoking the user defined <cite>run</cite> method.</p>
<p>There are several runners that are provided as part of Stitch, <cite>MapRunner</cite> and <cite>SeqRunner</cite> which
were discussed previously in the <a class="reference internal" href="Groups.html#groups"><span class="std std-ref">Groups</span></a> section. There’s also a <cite>BucketedMapRunner</cite> and a
<cite>BucketedSeqRunner</cite> which behave as described in the <a class="reference internal" href="#bucketed-groups"><span class="std std-ref">Bucketed Groups</span></a> section.
There’s also a non-batched <cite>FutureRunner</cite> which is what powers <a class="reference internal" href="BasicExamples.html#callfuture"><span class="std std-ref">CallFuture</span></a></p>
<p>Next <a class="reference internal" href="Arrows.html#arrows"><span class="std std-ref">Arrows</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Stitch</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchVsFuture.html">Stitch vs Future</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhyUseStitch.html">Why use Stitch?</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicExamples.html">Basic Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="FailureHandling.html">Failure handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Groups.html">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="ServiceAdapters.html">Service Adapters</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchConcepts.html">Stitch Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="QueryExecution.html">Query Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html">Running</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html#never-re-runnable">Never Re-Runnable</a></li>
<li class="toctree-l1"><a class="reference internal" href="EfficientQueries.html">Efficient Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchCache.html">StitchCache</a></li>
<li class="toctree-l1"><a class="reference internal" href="TwitterLocals.html">Twitter Locals</a></li>
<li class="toctree-l1"><a class="reference internal" href="Recursion.html">Recursion</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Advanced</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ordering">Ordering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bucketed-groups">Bucketed Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runners">Runners</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Arrows.html">Arrows</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Recursion.html" title="previous chapter">Recursion</a></li>
      <li>Next: <a href="Arrows.html" title="next chapter">Arrows</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/Advanced.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>