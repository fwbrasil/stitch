<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Basic Examples &#8212; Stitch  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Failure handling" href="FailureHandling.html" />
    <link rel="prev" title="Why use Stitch?" href="WhyUseStitch.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="basic-examples">
<span id="id1"></span><h1>Basic Examples<a class="headerlink" href="#basic-examples" title="Link to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure you have followed the instructions in <a class="reference internal" href="Setup.html#setup"><span class="std std-ref">Setup</span></a> for importing dependencies before running examples.</p>
</div>
<section id="const">
<span id="id2"></span><h2>Const<a class="headerlink" href="#const" title="Link to this heading">¶</a></h2>
<p>In the below example we will go over transforming data and composing Stitches together.</p>
<p>The most basic example of a Stitch is a <cite>Stitch.const</cite>, this is analogous to a <cite>Future.const</cite>.</p>
<p>We can use <cite>Stitch.value</cite> and <cite>Stitch.exception</cite> to make our intentions clear when using a <cite>const</cite>.
<cite>Stitch.const</cite>, <cite>.value</cite>, and <cite>.exception</cite> are by value so they aren’t evaluated lazily.
The same applies to <cite>Stitch.apply</cite>, which is analogous to <cite>Future.apply</cite>,
in that it wraps a computation and returns a <cite>Stitch</cite> (instead of a <cite>Future</cite>),
<cite>.apply</cite> is evaluated eagerly as well.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="c1">// result: 0</span>
</pre></div>
</div>
<img alt="A graph showing a const becoming the final value" src="_images/Const.png" />
<p><cite>Stitch.const</cite>, <cite>Stitch.value</cite>, and <cite>Stitch.exception</cite> are slightly different compared to other
Stitches since <a class="reference internal" href="Running.html#never-re-runnable"><span class="std std-ref">unlike other Stitches, these are safe to re-run</span></a>.</p>
</section>
<section id="transformations-and-effects">
<span id="transformations-effects"></span><h2>Transformations and Effects<a class="headerlink" href="#transformations-and-effects" title="Link to this heading">¶</a></h2>
<p>By running the Stitch we get a Future that will complete when the Stitch is done.
In the above example the future will contain the value 0.
We can expand on the above example by composing some simple transformations
that you’re likely familiar with from Futures.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">flatMap</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">onSuccess</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;It was successful! We got </span><span class="si">$</span><span class="n">v</span><span class="s">&quot;</span><span class="p">))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: 2</span>
</pre></div>
</div>
<img alt="A graph showing multiple transformations and a side effect" src="_images/TransformTransformEffect.png" />
<p>The above will yield a value of 2 and print “<cite>It was successful! We got 2</cite>”.
The above was a straightforward transformation and side effect.
But since it’s important to ensure that all parts of the Stitch you want to
run are included in the final Stitch, let’s go over how to do this more generally.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">applyEffect</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="nc">Stitch</span>
<span class="w">        </span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="nc">Duration</span><span class="p">.</span><span class="n">fromSeconds</span><span class="p">(</span><span class="mi">3</span><span class="p">))(</span><span class="k">new</span><span class="w"> </span><span class="nc">JavaTimer</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this is a side effect&quot;</span><span class="p">)))</span>
<span class="w">    </span><span class="p">.</span><span class="n">flatMap</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="c1">// paste the below in separately due to an issue with the repl</span>

<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: 2</span>
</pre></div>
</div>
<img alt="A graph showing multiple transformations and a sleep" src="_images/TransformSleep.png" />
<p>In the above snippet we are utilizing <cite>applyEffect</cite> to let us run any
arbitrary Stitch as a side effect. This kind of composition is
important to ensure that side effects actually execute.
This is called out more later in the <a class="reference internal" href="StitchConcepts.html#lazy"><span class="std std-ref">Lazy</span></a> section,
but to have the side effect run we need to ensure that these
side effects become part of the Stitch that is run. In this case,
the Stitch’s completion is delayed until the side effect is completed.</p>
<p>When something is added as an effect, it is added to the query,
but that doesn’t make it asynchronous. A Stitch will normally complete
only after all parts of the execution graph are completed. However,
if you want to fire-and-forget then you can use <cite>Stitch.async</cite>.
An async Stitch is special in a few ways, if it fails, the original
Stitch won’t be impacted, and the Future returned by <cite>Stitch.run</cite> will
complete even if the async operation has not.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">applyEffect</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">async</span><span class="p">(</span>
<span class="w">        </span><span class="nc">Stitch</span>
<span class="w">          </span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="nc">Duration</span><span class="p">.</span><span class="n">fromSeconds</span><span class="p">(</span><span class="mi">5</span><span class="p">))(</span><span class="k">new</span><span class="w"> </span><span class="nc">JavaTimer</span><span class="p">())</span>
<span class="w">          </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this is an async side effect&quot;</span><span class="p">))))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: 0, completes without waiting</span>
</pre></div>
</div>
<img alt="A graph showing multiple transformations and an async sleep" src="_images/TransformAsyncSleep.png" />
<p>Even though the effect will sleep for 5 seconds before completing,
the returned Future will complete without waiting,
“this is an async side effect” will be printed after the returned
Future is already completed.</p>
</section>
<section id="join-collect-and-traverse">
<span id="join-collect-traverse"></span><h2>Join, Collect, and Traverse<a class="headerlink" href="#join-collect-and-traverse" title="Link to this heading">¶</a></h2>
<p><cite>join</cite> lets you join Stitches together so they become part of the same query.
By joining Stitches together, operations can be batched across all the joined Stitches.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: (0, 1, 2)</span>
</pre></div>
</div>
<img alt="A graph showing 4 Stitches being joined together" src="_images/Join4.png" />
<p>Oftentimes you will want to query over a large number of input items,
however <cite>join</cite> is only useful for small tuples.
Stitch provides both <cite>collect</cite> and <cite>traverse</cite> functions to connect
large numbers of Stitch queries together.</p>
<p><cite>collect</cite> lets you take a <cite>Seq</cite>, <cite>Map</cite>, or <cite>Option</cite> of Stitches
and run them together as part of the same query, similar to <cite>join</cite>.
By collecting all the Stitches together, calls across all the
Stitches can be batched together.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">collect</span><span class="p">(</span><span class="nc">Seq</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: Seq(0,1,2,3)</span>
</pre></div>
</div>
<img alt="A graph showing 4 Stitches being collected together" src="_images/Join4.png" />
<p>With <cite>traverse</cite> you can define a function that will build a Stitch for each input.
With <cite>collect</cite> you need to have each query built up, but with <cite>traverse</cite>,
you only need the input necessary to generate the query.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="nc">Seq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)){</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)}</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: Seq(1,2,3,4)</span>
</pre></div>
</div>
<p><cite>traverse</cite> is equivalent to a <cite>collect</cite> where you map over the input Seq to make each Stitch</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">collect</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Seq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: Seq(1,2,3,4)</span>
</pre></div>
</div>
<img alt="A graph showing 4 Stitches being traversed together" src="_images/Join4.png" />
<p>A common mistake is to have multiple independent <cite>Stitch.run</cite> calls by doing something like</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">requests</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">mkStitch</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="nc">T</span><span class="p">):</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">[</span><span class="nc">U</span><span class="p">]</span>

<span class="n">requests</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">mkStitch</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Future</span><span class="p">[</span><span class="nc">U</span><span class="p">]]</span>
</pre></div>
</div>
<p>This could be rewritten as <cite>Stitch.run(Stitch.traverse(requests)(mkStitch)) : Future[Seq[U]]</cite>
to take full advantage of Stitch’s batching across all the Stitches.</p>
</section>
<section id="refs">
<span id="id3"></span><h2>Refs<a class="headerlink" href="#refs" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="Running.html#never-re-runnable"><span class="std std-ref">Each Stitch must only ever be run once</span></a>,
but parts of a Stitch can be reused elsewhere in the same Stitch.
When part of a Stitch is reused within the same Stitch,
it will be executed each time.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="nc">Unit</span><span class="p">.</span><span class="n">onSuccess</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this will execute twice&quot;</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="p">.</span><span class="n">before</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
</pre></div>
</div>
<p>This Stitch will run similar to this, with the transform (<cite>onSuccess</cite>) occurring again</p>
<img alt="A graph showing a Stitch where part of it is run again" src="_images/Reused.png" />
<p>We can flatten this to this simpler graph.</p>
<img alt="A graph showing a Stitch where part of it is run again, but this time the representation is flattened" src="_images/ReusedFlattened.png" />
<p>In the above example, “<cite>this will execute twice</cite>” prints out twice.
This differs from <cite>Future</cite> where once it’s run the result is memoized so it’s
only ever executed once. There will be times where this type of multiple
execution will be desired but there will also be occasions where it’s not.
That’s where <cite>Stitch.ref</cite> comes in.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">ref</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="nc">Unit</span><span class="p">.</span><span class="n">onSuccess</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this will execute once&quot;</span><span class="p">)))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="p">.</span><span class="n">before</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
</pre></div>
</div>
<p>With the <cite>ref</cite>, the result of the transform (<cite>onSuccess</cite>) essentially
becomes a <cite>const</cite> which is simply accessed for it’s value instead of a
Stitch that gets executed.</p>
<img alt="A graph showing the result of a Stitch transform beimg memoized" src="_images/Ref.png" />
<p>With a <cite>Stitch.ref</cite>, once the ref has been run in one part of the Stitch,
when it’s used again in another part of the Stitch, it will just get the
result and not execute again.</p>
</section>
<section id="callfuture">
<span id="id4"></span><h2>CallFuture<a class="headerlink" href="#callfuture" title="Link to this heading">¶</a></h2>
<p>Futures can be composed within Stitches using <cite>Stitch.callFuture</cite>.
This lets you use code which works in terms of Futures within Stitch.</p>
<p>In this example we have a <cite>mockServiceCall</cite> which simulates making
a call to a service by sleeping then returning a result.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">timer</span><span class="p">:</span><span class="w"> </span><span class="nc">Timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">JavaTimer</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">mockServiceCall</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">Future</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="nc">Duration</span><span class="p">.</span><span class="n">fromSeconds</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">callFuture</span><span class="p">(</span><span class="n">mockServiceCall</span><span class="p">())</span>

<span class="c1">// paste the below in separately due to an issue with the repl</span>

<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: 0, after a 1sec delay</span>
</pre></div>
</div>
<img alt="A graph showing the execution of a CallFuture" src="_images/CallFuture.png" />
<p>Using <cite>callFuture</cite> can allow you to easily inter-operate with Futures, however
it can come at a cost and it can negatively impact downstream batching behavior.
In some cases it may be beneficial to utilize <a class="reference internal" href="Groups.html#groups"><span class="std std-ref">Groups</span></a> instead as they will
generally have better batching behavior for downstream calls.</p>
</section>
<section id="calls">
<span id="id5"></span><h2>Calls<a class="headerlink" href="#calls" title="Link to this heading">¶</a></h2>
<p>The most fundamental operation in Stitch is an atomic query.
A Stitch atomic query is represented by a <cite>call</cite>, which accepts a single key and returns a single value.
The key can be any type <cite>K</cite> and the value can be of any type <cite>V</cite> .
A Stitch call also requires a <a class="reference internal" href="Groups.html#groups"><span class="std std-ref">group</span></a> to handle the batching.</p>
<p>So far we have covered transformations and integration with Futures, however
none of these take advantage of the main benefit you get from using Stitch,
batching. This is where <cite>Stitch.call</cite> comes in. A <cite>Stitch.call</cite> accepts
a single key and returns a single value but behind the scenes it handles
batching for you.</p>
<p>Most services abstract away the actual <cite>call</cite> but not all do.
If they don’t or if you are writing a <a class="reference internal" href="ServiceAdapters.html#service-adapters"><span class="std std-ref">Service Adapter</span></a>
then you’ll need a <cite>Group</cite>. Groups aggregate calls during Stitch graph
simplification. The details of <cite>Groups</cite> are covered in <a class="reference internal" href="Groups.html#groups"><span class="std std-ref">the Group section</span></a>,
but for now, think of these <cite>Groups</cite> as ways to call a service that adds 1 to an integer.</p>
<p>In the below example, we have a group <cite>g</cite>, this group simply adds 1 the argument passed into it.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SeqGroup</span><span class="p">[</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nc">Int</span><span class="p">]{</span>
<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Int</span><span class="p">]):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Try</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="nc">Future</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Return</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="p">}</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: 1</span>
</pre></div>
</div>
<img alt="A graph showing the execution of a Call with a single argument" src="_images/Call.png" />
<p>A <cite>Stitch.call</cite> is just another type of Stitch and can be composed with other Stitches.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SeqGroup</span><span class="p">[</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nc">Int</span><span class="p">]{</span>
<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Int</span><span class="p">]):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Try</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="nc">Future</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Return</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="p">}</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">join</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">),</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="c1">// result: (1,2)</span>
</pre></div>
</div>
<img alt="A graph showing the batching behavior of a Call with with multiple arguments" src="_images/CallBatching.png" />
<p>With these 2 Stitch queries joined, when they are run, they get batched together.</p>
<p>Next <a class="reference internal" href="FailureHandling.html#failure-handling"><span class="std std-ref">Failure handling</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Stitch</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchVsFuture.html">Stitch vs Future</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhyUseStitch.html">Why use Stitch?</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#const">Const</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transformations-and-effects">Transformations and Effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#join-collect-and-traverse">Join, Collect, and Traverse</a></li>
<li class="toctree-l2"><a class="reference internal" href="#refs">Refs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#callfuture">CallFuture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calls">Calls</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="FailureHandling.html">Failure handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Groups.html">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="ServiceAdapters.html">Service Adapters</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchConcepts.html">Stitch Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="QueryExecution.html">Query Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html">Running</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html#never-re-runnable">Never Re-Runnable</a></li>
<li class="toctree-l1"><a class="reference internal" href="EfficientQueries.html">Efficient Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchCache.html">StitchCache</a></li>
<li class="toctree-l1"><a class="reference internal" href="TwitterLocals.html">Twitter Locals</a></li>
<li class="toctree-l1"><a class="reference internal" href="Recursion.html">Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="Advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrows.html">Arrows</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="WhyUseStitch.html" title="previous chapter">Why use Stitch?</a></li>
      <li>Next: <a href="FailureHandling.html" title="next chapter">Failure handling</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/BasicExamples.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>