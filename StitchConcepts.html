<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Stitch Concepts &#8212; Stitch  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Query Execution" href="QueryExecution.html" />
    <link rel="prev" title="Service Adapters" href="ServiceAdapters.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="stitch-concepts">
<span id="id1"></span><h1>Stitch Concepts<a class="headerlink" href="#stitch-concepts" title="Link to this heading">¶</a></h1>
<section id="lazy">
<span id="id2"></span><h2>Lazy<a class="headerlink" href="#lazy" title="Link to this heading">¶</a></h2>
<p>Most Stitches are lazy. This is an important distinction from Futures.
If you build up a Stitch query but never call <cite>Stitch.run</cite> on it, then it never runs.</p>
<p>Whereas with Futures, you can take an arbitrary future and do <cite>future.ensure(…)</cite>,
and whenever the <cite>future</cite> is finished, the body of <cite>.ensure</cite> will run.
With Stitch, you must be careful to ensure all parts of the computation that you
want to run are part of the Stitch that is passed into <cite>Stitch.run</cite>.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="nc">Unit</span><span class="p">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this will run&quot;</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="p">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this won&#39;t run&quot;</span><span class="p">))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s0</span><span class="p">))</span>
</pre></div>
</div>
<img alt="A graph showing a Stitch with a detached part that never runs" src="_images/LazyDetached.png" />
<p>In the above example, <cite>s0</cite> is run but since only <cite>s0</cite> was run and not <cite>s1</cite>,
<cite>sideEffect</cite> never executes. Because of this, it’s important to ensure that the
Stitch that is run contains all computations you want executed.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="nc">Unit</span><span class="p">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this will run&quot;</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="p">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this will also run&quot;</span><span class="p">))</span>
<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
</pre></div>
</div>
<img alt="A graph showing a Stitch where all parts are run" src="_images/Lazy.png" />
<p>While most Stitches are lazily evaluated, <a class="reference internal" href="BasicExamples.html#const"><span class="std std-ref">Const</span></a> Stitches are evaluated eagerly.
This means that even without a <cite>Stitch.run</cite>, that “<cite>this will run</cite>” will print
in the below example. This comes up when using <a class="reference internal" href="TwitterLocals.html#twitter-locals"><span class="std std-ref">Twitter Locals</span></a>.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this will run&quot;</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="p">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;this won&#39;t run&quot;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="automatic-batching">
<span id="id3"></span><h2>Automatic Batching<a class="headerlink" href="#automatic-batching" title="Link to this heading">¶</a></h2>
<p>Stitch will automatically batch calls to the same backend together. This allows Stitch to
enable users to efficiently batch calls and take advantage of batch APIs. Using batch APIs
is often more efficient than making many individual calls to backend services since RPCs
are generally expensive to make and have high overhead, so reducing the number of RPCs but
increasing their size will usually be beneficial.</p>
<p>Stitch automatically batches calls to the same backend together, this means
that whether you talk to 1 or 100 backends, Stitch will handle ensuring that
calls to each backend are batched.</p>
<p>More detail about how automatic batching works is covered in the <a class="reference internal" href="QueryExecution.html#query-execution"><span class="std std-ref">Query Execution section</span></a>.</p>
</section>
<section id="deduplication-and-non-idempotent-calls">
<span id="deduplication-non-idempotent-calls"></span><h2>Deduplication and Non-Idempotent Calls<a class="headerlink" href="#deduplication-and-non-idempotent-calls" title="Link to this heading">¶</a></h2>
<p>When Stitch batches calls in a <a class="reference internal" href="Groups.html#groups"><span class="std std-ref">Group</span></a>, it deduplicates all collected calls using equality.
This is good for idempotent calls where deduplication is ideal but can be a surprise for non-idempotent calls.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">globalCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AtomicInteger</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SeqGroup</span><span class="p">[</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nc">Int</span><span class="p">]{</span>
<span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Int</span><span class="p">]):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Try</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;the batch was: [</span><span class="si">${</span><span class="n">keys</span><span class="p">.</span><span class="n">mkString</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span><span class="si">}</span><span class="s">]&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="nc">Future</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Return</span><span class="p">(</span><span class="n">globalCounter</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">())))</span>
<span class="p">}}</span>

<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">join</span><span class="p">(</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">),</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">),</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">),</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">))</span><span class="w"> </span><span class="c1">// result: (1, 1, 2, 2) OR (2, 2, 1, 1)</span>

<span class="n">globalCounter</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="c1">// result: 2</span>
</pre></div>
</div>
<p>In the above example, there will be a single batch of size 2 containing the values 0 and 1.
However, this yields unexpected results if it isn’t idempotent, this can be worked around
for non-idempotent calls by composing them to avoid this behavior at the expense of losing
batching between these calls.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">flatMap</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">join</span><span class="p">(</span>
<span class="w">        </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">),</span>
<span class="w">        </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">))</span>
<span class="p">)))</span><span class="w"> </span><span class="c1">// result: (3, 4) OR (4, 3)</span>
</pre></div>
</div>
<p>Here we’ve created a dependency between the first and second call which prevents
them from being batched. This may work for many cases but it won’t be ideal since
incorrectly composing a Stitch can result in calls unexpectedly being deduplicated.</p>
<p>The recommended way is to wrap the types so they won’t deduplicate, regardless of
how the Stitch is composed. This is done with a wrapper class that doesn’t compare
the underlying value when checking for equality, however Stitch will still deduplicate
the wrapper class based on reference equality. For example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DontDeduplicate</span><span class="p">[</span><span class="nc">T</span><span class="p">](</span><span class="kd">val</span><span class="w"> </span><span class="n">v</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="n">globalCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AtomicInteger</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SeqGroup</span><span class="p">[</span><span class="nc">DontDeduplicate</span><span class="p">[</span><span class="nc">Int</span><span class="p">],</span><span class="w"> </span><span class="nc">Int</span><span class="p">]{</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span>
<span class="w">    </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">DontDeduplicate</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Try</span><span class="p">[</span><span class="nc">Int</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;the batch was: [</span><span class="si">${</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">v</span><span class="p">).</span><span class="n">mkString</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span><span class="si">}</span><span class="s">]&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nc">Future</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="nc">Return</span><span class="p">(</span><span class="n">globalCounter</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">())))</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kd">val</span><span class="w"> </span><span class="n">refEqual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">DontDeduplicate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">valEqual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">DontDeduplicate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="nc">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="nc">Stitch</span><span class="p">.</span><span class="n">run</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">join</span><span class="p">(</span>
<span class="w">    </span><span class="c1">// reference equality is still deduplicated</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">refEqual</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">),</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">refEqual</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">),</span>
<span class="w">    </span><span class="c1">// value equality is no longer deduplicated</span>
<span class="w">    </span><span class="nc">Stitch</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">valEqual</span><span class="p">,</span><span class="w"> </span><span class="n">globalIncrementGroup</span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">))</span><span class="w"> </span><span class="c1">// result: (1, 1, 2) OR (2, 2, 1)</span>
</pre></div>
</div>
<p>The wrapper class adds additional work by allocating these extra objects but will
reliably prevent deduplication while maintaining batching.</p>
<p>Next <a class="reference internal" href="QueryExecution.html#query-execution"><span class="std std-ref">Query Execution</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Stitch</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchVsFuture.html">Stitch vs Future</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhyUseStitch.html">Why use Stitch?</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicExamples.html">Basic Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="FailureHandling.html">Failure handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Groups.html">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="ServiceAdapters.html">Service Adapters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Stitch Concepts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lazy">Lazy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#automatic-batching">Automatic Batching</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deduplication-and-non-idempotent-calls">Deduplication and Non-Idempotent Calls</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="QueryExecution.html">Query Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html">Running</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html#never-re-runnable">Never Re-Runnable</a></li>
<li class="toctree-l1"><a class="reference internal" href="EfficientQueries.html">Efficient Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="StitchCache.html">StitchCache</a></li>
<li class="toctree-l1"><a class="reference internal" href="TwitterLocals.html">Twitter Locals</a></li>
<li class="toctree-l1"><a class="reference internal" href="Recursion.html">Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="Advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrows.html">Arrows</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ServiceAdapters.html" title="previous chapter">Service Adapters</a></li>
      <li>Next: <a href="QueryExecution.html" title="next chapter">Query Execution</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/StitchConcepts.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>